import { from } from 'most'
// After 1 second, logs 10
from([1, 2, 3, 4])
    .delay(1000)
    .reduce((result, y) => result + y, 0)
    .then(result => console.log(result))

***************************************************************** 

const stream = most.of('hello');
stream.observe(x => console.log(x)); // logs hello

m.ret(3).bnd(v => {
  const stream1 = most.of(ti_RESULT).delay(1);
  stream1.observe(x => x = `x = ${v}`);
};
m.bnd(cube).bnd(m.ret).bnd(v => {
  const stream2 = most.of(ti2_RESULT_1).delay(2);
  stream2.observe(x => x = `${v}`);
};
m.bnd(add,15).bnd(m.ret).bnd(v => {
  const stream3 = most.of(ti2_RESULT_2).delay(3);
  stream3.observe(x => x = `${v}`);
};



// Use `just` for destructured ES6 import
import { just } from 'most';
const stream = just('hello');
stream.observe(x => console.log(x));

******************************************************************

delay

stream.delay(delayTime) -> Stream

most.delay(delayTime, stream) -> Stream

Timeshift a stream by delayTime.

stream:          -a-b-c-d->
stream.delay(1): --a-b-c-d->
stream.delay(5): ------a-b-c-d->
Delaying a stream timeshifts all the events by the same amount. Delaying doesn't change the time between events.

