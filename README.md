MonadState("travMonad", [[8,8,8,8], 0, 0, [ [ [], 0, 0 ] ] ], trav_state)
  
  function trav_state (ar) {
    pMindex.bnd(add,1).bnd(pMindex.ret);
    var nums = ar[0];
    var score = ar[1];
    var goals = ar[2];
    var next = travMonad.s.slice();
    var ar = [nums, score, goals];
    next[0] = nums;
    next[1] = score;
    next[2] = goals;
    next[3].unshift(ar);
    return next;         // This results in travMonad.s == next.
  }
```  
The number display is generated by four virtual button nodes with id = i, st yle: {display: get(pMstyle)[i]} and text get(pMnums)[i] for i = 0, 1, 2, and 3. The virtual button nodes rest permanently in the virtual DOM. pMnums and pMstyle are updated in the messages$ stream whenever a new dice roll is received from the server. pMnums and pMstyle are also re-set when a user clicks a number, causing it to disappear from the display and when when a user clicks a number or an operator button prompting a call to updateCalc, which either causes a new roll or a computed number to be added to the display. numClickAction$ and opClickAction$ are merged into the stream that feeds the virtual DOM, so updates are seen almost instantaneously.

Whenever pMnums changes, the expression pMnums.bnd(test3).bnd(pMstyle.ret) updates pMstyle so as to hide undefined values of get(pMnumes)[i] for i = 0, 1, 2, and 3.
```javascript
  function test3 (a) {
    var b = [];
    for (let i of [0,1,2,3]) {
      b[i] = (a[i] == undefined) ? 'none' : 'inline'
    }
    return ret(b);
  }  

  pMnums.bnd(test3).bnd(pMstyle.ret);  
```  
New dice rolls always correspond to score changes. One point is lost each time a player clicke ROLL. Scores increase whenever players put together expressions that return 18 or 20. An increase in score is always accompanied by a call to newRoll() with two arguments: score and goals. The server updates its ServerState TMVar and broadcasts the new roll to all group members with the prefix "CA#$42. The server also broadcasts the updated score and goal information, with the prefix NN#$42. These messages are caught, parsed, and acted upon in the message$ stream in the Motorcycle front end. pMnums, pMstyle, and travMonad get updated during the course of this process.
```javascript
  mMZ10.bnd( () => {
    pMnums.ret([v[3], v[4], v[5], v[6]]).bnd(test3).bnd(pMstyle.ret)
    travMonad.run([ [v[3], v[4], v[5], v[6]], v[7], v[8] ]);
    pMscore.ret(v[7]);
    pMgoals.ret(v[8]) });  
```
###Updating the numbers

The previous discusion was about traversal of the game history. This seems like a good place to look at the algorithm for generating new numbers when players click on the number and operator buttons. Here is the code:
```javascript
  var numClick$ = sources.DOM
      .select('.num').events('click'); 

  var numClickAction$ = numClick$.map(e => {
    if (get(mM3).length == 2) {return};
    pMnums    
    .bnd(spliceM, e.target.id, 1)
    .bnd(pMnums.ret)
    .bnd(test3)
    .bnd(pMstyle.ret)
    mM3
    .bnd(push, e.target.innerHTML)
    .bnd(mM3.ret)
    .bnd(v => {
      if (v.length == 2 && get(mM8) != 0) {
        updateCalc(v, get(mM8)) 
      }
    })
    }).startWith([0, 0, 0, 0]);

  var opClick$ = sources.DOM
      .select('.op').events('click');

  var opClickAction$ = opClick$.map(e => {
    mM8.ret(e.target.innerHTML).bnd(v => { 
      var ar = get(mM3)
      if (ar.length === 2) {
        updateCalc(ar, v)
      }
    }) 
  });
```
The clicked number is removed from pMnums and added to mM3 in the numClickAction$ stream. If two numbers and an operator have been selected, numClickAction$ and opClickAction$ call updateCalc, giving it the two member array (which is held in mM3) of selected numbers and the selected operator. After each roll, mM8 is given the value 0 so get(mM8) != 0 means an operator has been selected. 
```javascript
  function updateCalc(ar, op) {
    var result = calc(ar[0], op, ar[1]);
    mM3.ret([]);
    mM8.ret(0)
    if (result == 20) { 
      pMscore.bnd(add,1)
      .bnd(testscore)
      .bnd(pMscore.ret)
      .bnd(v => score(v));
      return; 
    } 
    else if (result == 18) { 
      pMscore.bnd(add,3)
      .bnd(testscore)
      .bnd(pMscore.ret)
      .bnd(v => score(v));
      return; 
    }
    else {
      pMnums.bnd(push,result)
      .bnd(pMnums.ret)
      .bnd(v => {
        travMonad.run([v, get(pMscore), get(pMgoals)])
        test3(v)
        .bnd(pMstyle.ret)
      }); 
      mM8.ret(0);
      mM3.ret([]);
      console.log('in updateCalc 1111111111 get(pMnums), get(pMstyle) ', get(pMnums), get(pMstyle) );
    }
  };  

  var testscore = function testscore(v) {
    if ((v % 5) === 0) return ret(v+5)
    else return ret(v);
  };

  function score(scor) {
    if (scor != 25) {
      newRoll(scor, get(pMgoals))
    }
    else if (get(pMgoals) == 2) {
      newRoll(0,0)
    }
    else {pMgoals.bnd(add, 1).bnd(pMgoals.ret).bnd(g => newRoll(0, g))};
  };  

```  
updateCalc calls calc on the numbers and operater given to it by numCalcAction$ or opCalcAction$, giving the value to a variable named "result". If the value of result is 18 or 20, the resulting score is checked to see if it should be augmented by five and then score(scor) is called, providing the new score to the function score(). score() performs some more tests and calls for a new roll with the values of score and goals it has determined depending on whether or not there is a score and, if so, a winner.
##MonadSet
The list of online group members at the bottom of the scoreboard is very responsive to change. When someone joins the group, changes to a different group, or closes a browser session, a message prefixed by NN#$42 goes out from the server providing group members with the updated list of group members. MonadSet acts upon messages prefixed by NN#$42. Here are the definitions of MonadSet and the MonadSet instance sMplayers
```javascript
  var MonadSet = function MonadSet(set, ID) {
    var _this = this;
  
    this.s = set;
  
    if (arguments.length === 1) this.id = 'anonymous';
    else this.id = ID;
  
    this.bnd = function (func, ...args) {
       return func(_this.x, ...args);
    };
  
    this.add = function (a) {
      var ar = Array.from(_this.s);
      set = new Set(ar);
      set.add(a);
      window[_this.id] = new MonadSet(set, _this.id);
      return window[_this.id];
    };
  
    this.delete = function (a) {
      var ar = Array.from(_this.s);
      set = new Set(ar);
      set.delete(a);
      window[_this.id] = new MonadSet(set, _this.id);
      return window[_this.id];
    };
  
    this.clear = function () {
      set = new Set([]);
      window[_this.id] = new MonadSet(set, _this.id);
      return window[_this.id];
    };
  };
  
  var s = new Set();
  
  var sMplayers = new MonadSet( s, 'sMplayers' )  
```
## MonadE - An Error-Catching Monad
Instances of MonadE function much the same as instances of Monad, but When an instance of MonadE encounters an error, it ceases to perform any further computations, propagating the error to the end of the sequence it is in. Functions used as arguments to the MonadE bnd() method are placed in quotation marks to prevent the browser engine from throwing reference errors. Arguments can be protected in the same manner. The screen shot (below) taken after running the following expressions in the Google Chrome console shows the logs resulting from running the error-free version and then the version with an error.
```Javascript
  ret2(0,'a').bnd('add2',3)
  .bnd('mult2',100)
  .bnd(a.ret)
  .bnd('square2')  
  .bnd("ret2(0,'c').ret")  
   .bnd(() => {
    ret2(0,'b')
    .bnd('add2',4)
   .bnd('mult2',100)
   .bnd('b.ret')
   .bnd("ret2(0,'d').ret")
   .bnd('square2')
   .bnd('d.ret')
   .bnd('add2',c.getx())
   .bnd('d.ret')
   .bnd('sqroot2')
   .bnd('d.ret')
   .bnd('log2','The square root of the sum of ' + a.getx() + 
        ' squared and ' + b.getx() + ' squared is ' + d.getx())    
  });
        
  ret2(0,'a').bnd('add22',3)
  .bnd('mult2',100)
  .bnd(a.ret)
  .bnd('square2')  
  .bnd("ret2(0,'c').ret")  
   .bnd(() => {
    ret2(0,'b')
    .bnd('add2',4)
   .bnd('mult2',100)
   .bnd('b.ret')
   .bnd("ret2(0,'d').ret")
   .bnd('square2')
   .bnd('d.ret')
   .bnd('add2',c.getx())
   .bnd('d.ret')
   .bnd('sqroot2')
   .bnd('d.ret')
   .bnd('log2','The square root of the sum of ' + a.getx() + 
        ' squared and ' + b.getx() + ' squared is ' + d.getx())    
  });
```
![Alt text](MonadE_a.png?raw=true)

Here are the definitions of MonadE and the functions used in the demonstration:
```Javascript
  function MonadE (val, ID, er = []) {
    var x = val;
    var e = er;
    var ob = {  
      id: ID,
  
      getx: function () {return x},
  
      bnd: function (f, ...args) {

        if (f == 'clean') {
          ret2(x, ob.id, []);
          return new MonadE(x, ob.id, [])
        }

        if (f == 'log2') {
          console.log(args[0]);
          return new MonadE(args[0], 'log', [])
        }
  
        if (e.length > 0) {
          console.log('BYPASSING COMPUTATION in MonadE instance', ob.id, f, '.  PROPAGATING ERROR:',  e[0]); 
          return ob;  
        }
  
        var a = ("typeof " + f);

        if (eval(a) == 'function') {
          let b = '';
          for (let v of args) {
            b = "typeof " + v
            if (eval(b) == 'undefined') {
              console.log(v, "is undefined. No further computations will be attempted");
              e.push(v + " is undefined." );
              return ob;
            }
  
            if (eval(b) == 'NaN') {
              console.log(v, "is NaN. No further computations will be attempted");
              e.push(v + " is NaN." );
              return ob;
            }
          }

          try {return eval(f)(x, ...args)}
          catch (error) {
            e.push(error);
            console.log('MonadE instance',ob.id,'generated the following error message:');
            console.log('Error ' + error);  
          }
        }
        
        else {
          e.push(f + ' is not a function. ');
          console.log(f, 'is not a function. No further computations will be attempted');
          return ob;
        }
      },
  
      ret: function (a) {
        window[ob.id] = new MonadE(a, ob.id, []);
        return window[ob.id];
      }  
    }
    return ob;
  };
  
  function add2 (x,a) {
    return ret2(x + a)
  }
  
  function square2 (x) {
    return ret2(x*x);
  };
  
  function mult2 (x,y) {
    return ret2(x*y);
  };
  
  function ret2(v, id = 'default', er = []) {
    window[id] = new MonadE(v, id, er);
    return window[id];
  }  
```
When a MonadE instance encounters a function or an argument in quotation marks of types undefined or NaN, a message string gets pushed into its e attribue. After that, the bnd() method will not process any function other than clean() and log2(). It will stop at the "if (e.length > 0)" block. clean() resets an instance to normal functioning mode by setting its e attribute back to []. a, b, c, and d are created on the fly in the error-free version. In the version with an error, a already exists and ret2(0,'a') re-sets a's value to 0.

The final test in the bnd() method occurs in a try-catch block. If a function and its quoted arguments are not of types undefined or NaN but the system returns an error, the error message gets logged and a browser crash is averted.

##Websocket messages

Incoming websockets messages trigger updates to the game display, the chat display, and the todo list display. The members of a group see what other members are doing; and in the case of the todo list, they see the current list when they sign in to the group. When any member of a group adds a task, crosses it out as completed, edits its description, or removes it, the server updates the persistent file and all members of the group immediately see the revised list.

The code below shows how incoming websockets messages are routed. For example, mMZ10.release() is called when a new dice roll (prefixed by CA#$42) comes in.
```javascript
  const messages$ = (sources.WS).map( e => {
  mMtem.ret(e.data.split(',')).bnd( v => {
  console.log('<><><><><><><><><><><><><><><><>  INCOMING  <><><><><><><> >>> In messages. e amd v are ', e, v);
  mMZ10.bnd( () => {
    pMnums.ret([v[3], v[4], v[5], v[6]]).bnd(test3).bnd(pMstyle.ret)
    travMonad.run([ [v[3], v[4], v[5], v[6]], v[7], v[8] ]);
    pMscore.ret(v[7]);
    pMgoals.ret(v[8]) }); 
  mMZ12.bnd( () => mM6.ret(v[2] + ' successfully logged in.'));
  mMZ13.bnd( () => updateMessages(e.data));
  mMZ14.bnd( () => mMgoals2.ret('The winner is ' + v[2]));
  mMZ15.bnd( () => {
    mMgoals2.ret('A player named ' + v[2] + ' is currently logged in. Page will refresh in 4 seconds.')
    refresh() });
  mMZ17.bnd( () => testTask(v[2], v[3], e.data) ); 
    mMZ18.bnd( () => {if (get(pMgroup) != 'solo' || get(pMname) == v[2]) {updatePlayers(e.data) } });
  })       
  mMtemp.ret(e.data.split(',')[0])
  .bnd(next, 'CA#$42', mMZ10)
  .bnd(next, 'CD#$42', mMZ13)
  .bnd(next, 'CE#$42', mMZ14)
  .bnd(next, 'EE#$42', mMZ15)
  .bnd(next, 'DD#$42', mMZ17)
  .bnd(next, 'NN#$42', mMZ18)
  });
```  
The "mMZ" prefix designates instances of MonadItter. An instance's bnd() method assigns its argument to its "p" attribute. "p" runs if and when its release() method is called. The next() function releases a specified MonadItter instance when the calling monad's value matches the specified value in the expression. In the messages$ stream, the MonadItter instance's bnd methods do not take argumants, but next is capable of sending arguments when bnd() is called on functions requiring them. Here is an example:

The online demonstration features a game with a traversible dice-roll history; group chat rooms; and a persistent, multi-user todo list. People in the same group share the game, chat messages, and whatever todo list they might have. Updating, adding, removing, or checking "Complete" by any member causes every member 's todo list to update. The Haskell websockets server preserves a unique text file for each group's todo list. Restarting the server does not affect the lists. Restarting or refreshing the browser window causes the list display to disappear, but signing in and re-joining the old group brings it back. If the final task is removed, the server deletes the group's todo text file. 

With Motorcycle.js, the application runs smoothly and is easy to understand and maintain. I say "easy to understand", but for people coming from an imperitive programming background, some effort must first be invested into getting used to functions that take functions as arguments, which are at the heart of Motorcycle and JS-monads-stable. After that, seeing how the monads work is a matter of contemplating their definitions and experimenting a little. Most of the monads and the functions they use in this demonstration are readily available in the browser console. If you have the right dev tools in Chrome or Firefox, just load [http://schalk.net:3055](http://schalk.net:3055) and press F12. You might need to enter Ctrl-R to re-load with access to the monad.js script. I do this to troubleshoot and experiment. 

.
.

